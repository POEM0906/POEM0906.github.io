<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Js——变量与作用域（全） | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="1.原始值与引用值ECMAScript变量可以包含两种不同类型的数据：原始值和引用值。在把一个值赋给变量时，JavaScript引擎必须确定这个值是原始值还是引用值。 原始值：就是最简单的数据。 包括Undefined、Null、Boolean、Number、String和Symbol。因为我们操作的就是存储在变量中的实际值，所以保存原始值的变量是按值访问的。 引用值：则是由多个值构成的对象。 引">
<meta property="og:type" content="article">
<meta property="og:title" content="Js——变量与作用域（全）">
<meta property="og:url" content="https://example.com/2021/05/01/JS%E5%8F%98%E9%87%8F%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="1.原始值与引用值ECMAScript变量可以包含两种不同类型的数据：原始值和引用值。在把一个值赋给变量时，JavaScript引擎必须确定这个值是原始值还是引用值。 原始值：就是最简单的数据。 包括Undefined、Null、Boolean、Number、String和Symbol。因为我们操作的就是存储在变量中的实际值，所以保存原始值的变量是按值访问的。 引用值：则是由多个值构成的对象。 引">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210415181054297.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1BPRU1fXw==,size_16,color_FFFFFF,t_70#pic_center">
<meta property="article:published_time" content="2021-05-01T15:16:27.517Z">
<meta property="article:modified_time" content="2021-05-01T15:21:53.813Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/20210415181054297.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1BPRU1fXw==,size_16,color_FFFFFF,t_70#pic_center">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-JS变量与作用域" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/05/01/JS%E5%8F%98%E9%87%8F%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F/" class="article-date">
  <time datetime="2021-05-01T15:16:27.517Z" itemprop="datePublished">2021-05-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Js——变量与作用域（全）
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-原始值与引用值"><a href="#1-原始值与引用值" class="headerlink" title="1.原始值与引用值"></a>1.原始值与引用值</h1><p>ECMAScript变量可以包含两种不同类型的数据：原始值和引用值。<br>在把一个值赋给变量时，JavaScript引擎必须确定这个值是原始值还是引用值。</p>
<p><strong>原始值</strong>：就是最简单的数据。</p>
<p>包括Undefined、Null、Boolean、Number、String和Symbol。<br>因为我们操作的就是存储在变量中的实际值，所以<strong>保存原始值的变量是按值访问的</strong>。</p>
<p><strong>引用值</strong>：则是由多个值构成的对象。</p>
<p>引用值是保存在内存中的对象。与其他语言不同，JavaScript不允许直接访问内存位置，因此也就不能直接操作对象所在的内存空间。在操作对象时，实际上操作的是对该对象的引用而非实际的对象本身。为此，<strong>保存引用值的变量是按引用访问的</strong>。</p>
<h2 id="1-1动态属性"><a href="#1-1动态属性" class="headerlink" title="1.1动态属性"></a>1.1动态属性</h2><p>原始值和引用值的定义方式很类似，都是创建一个变量，然后给它赋一个值。不过，在变量保存了这个值之后，可以对这个值做什么，则大有不同。对于<strong>引用值</strong>而言，<strong>可以随时添加、修改和删除其属性和方法</strong>。</p>
<p>比如，看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">person.name = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// &quot;Nicholas&quot;</span></span><br></pre></td></tr></table></figure>
<p>这里，首先创建了一个对象，并把它保存在变量person中。然后，给这个对象添加了一个名为name的属性，并给这个属性赋值了一个字串”Nicholas”。在此之后，就可以访问这个新属性，直到对象被销毁或属性被显式地删除。</p>
<p><strong>原始值不能有属性</strong>，尽管尝试给原始值添加属性不会报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line">name.age = <span class="number">27</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name.age); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>在此，代码想给字符串name定义一个age属性并给该属性赋值27。紧接着在下一行，属性不见了。记住，<strong>只有引用值可以动态添加后面可以使用的属性</strong>。</p>
<p>注意，原始类型的初始化可以只使用原始字面量形式。如果使用的是new关键字，则JavaScript会创建一个Object类型的实例，但其行为类似原始值。下面来看看这两种初始化方式的差异：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name1 = <span class="string">&quot;Nicholas&quot;</span>;  <span class="comment">//原始值不能附属性</span></span><br><span class="line"><span class="keyword">let</span> name2 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;Matt&quot;</span>);  <span class="comment">//使用new关键字，js创建object类型实例</span></span><br><span class="line">name1.age = <span class="number">27</span>;</span><br><span class="line">name2.age = <span class="number">26</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name1.age); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(name2.age); <span class="comment">// 26</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> name1); <span class="comment">// string  //类型</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> name2); <span class="comment">// object</span></span><br></pre></td></tr></table></figure>
<h2 id="1-2复制值"><a href="#1-2复制值" class="headerlink" title="1.2复制值"></a>1.2复制值</h2><p>除了存储方式不同，原始值和引用值在通过变量复制时也有所不同。</p>
<p>在通过变量把一个原始值赋值到另一个变量时，<strong>原始值会被复制到新变量的位置</strong>。请看下面的例子:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> num2 = num1;</span><br></pre></td></tr></table></figure>
<p>这里，num1包含数值5。当把num2初始化为num1时，num2也会得到数值5。这个值跟存储在num1中的5是完全独立的，因为它是那个值的副本。这两个变量可以独立使用，互不干扰。</p>
<p>在<strong>把引用值从一个变量赋给另一个变量时，存储在变量中的值也会被复制到新变量所在的位置</strong>。区别在于，这里复制的值实际上是一个指针，它指向存储在堆内存中的对象。操作完成后，两个变量实际上指向同一个对象，因此一个对象上面的变化会在另一个对象上反映出来，如下面的例子所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="keyword">let</span> obj2 = obj1;</span><br><span class="line">obj1.name = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj2.name); <span class="comment">// &quot;Nicholas&quot;</span></span><br></pre></td></tr></table></figure>
<p>变量obj1保存了一个新对象的实例。然后，这个值被复制到obj2，此时两个变量都指向了同一个对象。在给obj1创建属性name并赋值后，通过obj2也可以访问这个属性，因为它们都指向同一个对象。</p>
<h2 id="1-3传递参数"><a href="#1-3传递参数" class="headerlink" title="1.3传递参数"></a>1.3传递参数</h2><p>之前我们有讲到过访问，保存原始值的变量是按值访问，保存引用值的变量是按引用访问的。<br>但是ECMAScript中<strong>所有函数的参数都是按值传递的</strong>。这意味着函数外的值会被复制到函数内部的参数中，就像从一个变量复制到另一个变量一样。如果是原始值，那么就跟原始值变量的复制一样，如果是引用值，那么就跟引用值变量的复制一样。</p>
<p>在按值传递参数时，值会被复制到一个局部变量（即一个命名参数）。在按引用传递参数时，值在内存中的位置会被保存在一个局部变量，这意味着对本地变量的修改会反映到函数外部。（）这在ECMAScript中是不可能的。）来看下面这个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTen</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line"> num += <span class="number">10</span>;</span><br><span class="line"> <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> count = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">let</span> result = addTen(count);</span><br><span class="line"><span class="built_in">console</span>.log(count); <span class="comment">// 20，没有变化</span></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 30</span></span><br></pre></td></tr></table></figure>
<p>这里，函数addTen()有一个参数num，它其实是一个局部变量。在调用时，变量count作为参数传入。count的值是20，这个值被复制到参数num以便在addTen()内部使用。在函数内部，参数num的值被加上了10，但这不会影响函数外部的原始变量count。参数num和变量count互不干扰，它们只不过碰巧保存了一样的值。如果num是按引用传递的，那么count的值也会被修改为30。这个事实在使用数值这样的原始值时是非常明显的。但是，如果变量中传递的是对象，就没那么清楚了。比如，再看这个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line"> obj.name = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">setName(person);</span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// &quot;Nicholas&quot;</span></span><br></pre></td></tr></table></figure>
<p>这一次，我们创建了一个对象并把它保存在变量person中。然后，这个对象被传给setName()方法，并被复制到参数obj中。在函数内部，obj和person都指向同一个对象。结果就是，即使对象是按值传进函数的，obj也会通过引用访问对象。当函数内部给obj设置了name属性时，函数外部的对象也会反映这个变化，因为obj指向的对象保存在全局作用域的堆内存上。很多开发者错误地认为，当在局部作用域中修改对象而变化反映到全局时，就意味着参数是按引用传递的。为证明对象是按值传递的，我们再来看看下面这个修改后的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line"> obj.name = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line"> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"> obj.name = <span class="string">&quot;Greg&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">setName(person);</span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// &quot;Nicholas&quot;</span></span><br></pre></td></tr></table></figure>
<p>这个例子前后唯一的变化就是setName()中多了两行代码，将obj重新定义为一个有着不同name的新对象。当person传入setName()时，其name属性被设置为”Nicholas”。然后变量obj被设置为一个新对象且name属性被设置为”Greg”。如果person是按引用传递的，那么person应该自动将指针改为指向name为”Greg”的对象。可是，当我们再次访问person.name时，它的值是”Nicholas”，这表明函数中参数的值改变之后，原始的引用仍然没变。当obj在函数内部被重写时，它变成了一个指向本地对象的指针。而那个本地对象在函数执行结束时就被销毁了。</p>
<h2 id="1-4-确定类型"><a href="#1-4-确定类型" class="headerlink" title="1.4    确定类型"></a>1.4    确定类型</h2><p>typeof操作符最适合用来判断一个变量是否为原始类型。更确切地说，它是判断一个变量是否为字符串、数值、布尔值或undefined的最好方式。如果值是对象或null，那么typeof返 回”object”，如下面的例子所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> i = <span class="number">22</span>;</span><br><span class="line"><span class="keyword">let</span> u;</span><br><span class="line"><span class="keyword">let</span> n = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> s); <span class="comment">// string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> i); <span class="comment">// number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> b); <span class="comment">// boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> u); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> n); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> o); <span class="comment">// object</span></span><br></pre></td></tr></table></figure>
<p>typeof虽然对原始值很有用，但它对引用值的用处不大。我们通常不关心一个值是不是对象，而是想知道它是什么类型的对象。为了解决这个问题，ECMAScript提供了instanceof操作符，语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = variable <span class="keyword">instanceof</span> <span class="title">constructor</span></span><br></pre></td></tr></table></figure>
<p>如果变量是给定引用类型</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// 变量person是Object吗？</span></span><br><span class="line"><span class="built_in">console</span>.log(colors <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// 变量colors是Array吗？</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>); <span class="comment">// 变量pattern是RegExp吗？</span></span><br></pre></td></tr></table></figure>
<p>按照定义，所有引用值都是Object的实例，因此通过instanceof操作符检测任何引用值和Object构造函数都会返回true。类似地，如果用instanceof检测原始值，则始终会返回false，因为原始值不是对象。</p>
<h1 id="2-执行上下文与作用域"><a href="#2-执行上下文与作用域" class="headerlink" title="2.执行上下文与作用域"></a>2.执行上下文与作用域</h1><h2 id="2-1"><a href="#2-1" class="headerlink" title="2.1"></a>2.1</h2><p><strong>执行上下文</strong>变量或函数的上下文决定了它们可以访问哪些数据，以及它们的行为。每个上下文都有一个关联的变量对象，而这个上下文中定义的所有变量和函数都存在于这个对象上。虽然无法通过代码访问变量对象，但后台处理数据会用到它。</p>
<p>每个函数调用都有自己的上下文。当代码执行流进入函数时，函数的上下文被推到一个上下文栈上。在函数执行完之后，上下文栈会弹出该函数上下文，将控制权返还给之前的执行上下文。ECMAScript程序的执行流就是通过这个上下文栈进行控制的。</p>
<p>上下文中的代码在执行的时候，会创建变量对象的一个<strong>作用域链</strong>。这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序。代码正在执行的上下文的变量对象始终位于作用域链的最前端。如果上下文是函数，则其活动对象用作变量对象。活动对象最初只有一个定义变量：arguments。（全局上下文中没有这个变量。）作用域链中的下一个变量对象来自包含上下文，再下一个对象来自再下一个包含上下文。以此类推直至全局上下文；全局上下文的变量对象始终是作用域链的最后一个变量对象。</p>
<p>代码执行时的标识符解析是通过沿作用域链逐级搜索标识符名称完成的。搜索过程始终从作用域链的最前端开始，然后逐级往后，直到找到标识符。（如果没有找到标识符，那么通常会报错。）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (color === <span class="string">&quot;blue&quot;</span>) &#123;</span><br><span class="line"> color = <span class="string">&quot;red&quot;</span>;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> color = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">changeColor();</span><br></pre></td></tr></table></figure>
<p>对这个例子而言，函数changeColor()的作用域链包含两个对象：一个是它自己的变量对象，另一个是全局上下文的变量对象。这个函数内部之所以能够访问变量color，就是因为可以在作用域链中找到它。</p>
<p>此外，局部作用域中定义的变量可用于在局部上下文中替换全局变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">let</span> anotherColor = <span class="string">&quot;red&quot;</span>;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">swapColors</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">let</span> tempColor = anotherColor;</span><br><span class="line"> anotherColor = color;</span><br><span class="line"> color = tempColor;</span><br><span class="line"> <span class="comment">// 这里可以访问color、anotherColor和tempColor</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 这里可以访问color和anotherColor，但访问不到tempColor</span></span><br><span class="line"> swapColors();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里只能访问color</span></span><br><span class="line">changeColor();</span><br></pre></td></tr></table></figure>
<p>以上代码涉及3个上下文：全局上下文、changeColor()的局部上下文和swapColors()的局部上下文。全局上下文中有一个变量color和一个函数changeColor()。changeColor()的局部上下文中有一个变量anotherColor和一个函数swapColors()，但在这里可以访问全局上下文中的变量color。swapColors()的局部上下文中有一个变量tempColor，只能在这个上下文中访问到。全局上下文和changeColor()的局部上下文都无法访问到tempColor。而在swapColors()中则可以访问另外两个上下文中的变量，因为它们都是父上下文。</p>
<p><img src="https://img-blog.csdnimg.cn/20210415181054297.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1BPRU1fXw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>图 中的矩 形表示不同 的上下文。内部上下文可以通过作用域链访问外部上下文中的一切，但外部上下文无法访问内部上下文中的任何东西。上下文之间的连接是线性的、有序的。每个上下文都 可以到上一级上下文 中去搜 索变量和函数，但任何上下 文都不能到下一级上下文中去搜索。swapColors()局部上下文的作 用域链中有3个对 象：swapColors()的变量 对象、changeColor()的变量对象和 全局变量对象。swapColors()的局部上下文首先从自己的 变量对象开始 搜索变量 和函数，搜不到就去搜索上一 级变量对象。changeColor()上下文的作用域链中只有2个对象： 它自己的变量对象和全局 变量对象。因此 ，它不能访问swapColors() 的上下文。</p>
<h2 id="2-2作用域链增强"><a href="#2-2作用域链增强" class="headerlink" title="2.2作用域链增强"></a>2.2作用域链增强</h2><h2 id="2-3变量声明"><a href="#2-3变量声明" class="headerlink" title="2.3变量声明"></a>2.3变量声明</h2><h3 id="2-3-1-使用var的函数作用域声明"><a href="#2-3-1-使用var的函数作用域声明" class="headerlink" title="2.3.1 使用var的函数作用域声明"></a>2.3.1 使用var的函数作用域声明</h3><p>在使用var声明变量时，变量会被自动添加到最接近的上下文。<strong>在函数中</strong>，最接近的上下文就是函数的局部上下文。在with语句中，最接近的上下文也是函数上下文。<strong>如果变量未经声明就被初始化了</strong>，那么它就会自动被添加到全局上下文，如下面的例子所示：</p>
<ul>
<li>在函数中：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> sum = num1 + num2;</span><br><span class="line"> <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result = add(<span class="number">10</span>, <span class="number">20</span>); <span class="comment">// 30</span></span><br><span class="line"><span class="built_in">console</span>.log(sum); <span class="comment">// 报错：sum在这里不是有效变量</span></span><br></pre></td></tr></table></figure>

<p>这里，函数add()定义了一个局部变量sum，保存加法操作的结果。这个值作为函数的值被返回，但变量sum在函数外部是访问不到的。</p>
<ul>
<li>如果省略上面例子中的关键字var，那么sum在add()被调用之后就变成可以访问的了，如下所示：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line"> sum = num1 + num2;</span><br><span class="line"> <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result = add(<span class="number">10</span>, <span class="number">20</span>); <span class="comment">// 30</span></span><br><span class="line"><span class="built_in">console</span>.log(sum); <span class="comment">// 30</span></span><br></pre></td></tr></table></figure>

<p>这一次，变量sum被用加法操作的结果初始化时并没有使用var声明。在调用add()之后，sum被添加到了全局上下文，在函数退出之后依然存在，从而在后面可以访问到。</p>
<p><strong>提升</strong>：var声明会被拿到函数或全局作用域的顶部，位于作用域中所有代码之前。这个现象叫作“提升”。</p>
<p>提升让同一作用域中的代码不必考虑变量是否已经声明就可以直接使用。</p>
<p>下面的例子展示了在全局作用域中两段等价的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;Jake&quot;</span>;</span><br><span class="line"><span class="comment">// 等价于：</span></span><br><span class="line">name = <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> name;    <span class="comment">//即使声明在后</span></span><br></pre></td></tr></table></figure>

<p>下面是两个等价的函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> name = <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等价于：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> name;</span><br><span class="line"> name = <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通过在声明之前打印变量，可以验证变量会被提升</strong>。声明的提升意味着会输出undefined而不是Reference Error：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(name); <span class="comment">// undefined</span></span><br><span class="line"> <span class="keyword">var</span> name = <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-2-使用let的块级作用域声明"><a href="#2-3-2-使用let的块级作用域声明" class="headerlink" title="2.3.2 使用let的块级作用域声明"></a>2.3.2 使用let的块级作用域声明</h3><p>ES6新增的let关键字跟var很相似，但<strong>它的作用域是块级</strong>的，这也JavaScript中的新概念。</p>
<ul>
<li><strong>块级作用域由最近的一对包含花括号{}界定</strong>。换句话说，if块、while块、function块，甚至连单独的块也是let声明变量的作用域。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// ReferenceError: a没有定义</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// ReferenceError: b没有定义</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">let</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">// ReferenceError: c没有定义</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>let与var的另一个不同之处是在同一作用域内不能声明两次</strong>。重复的var声明会被忽略，而重复的let声明会抛出SyntaxError。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="comment">// 不会报错</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">let</span> b;</span><br><span class="line"> <span class="keyword">let</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// SyntaxError: 标识符b已经声明过了</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>let的行为非常适合在循环中声明迭代变量</strong>。使用var声明的迭代变量会泄漏到循环外部，这种情况应该避免。来看下面两个例子：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// 10</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; ++j) &#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(j); <span class="comment">// ReferenceError: j没有定义</span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-3使用const的常量声明"><a href="#2-3-3使用const的常量声明" class="headerlink" title="2.3.3使用const的常量声明"></a>2.3.3使用const的常量声明</h3><p>除了let，ES6同时还增加了const关键字。<strong>使用const声明的变量必须同时初始化为某个值</strong>。       <strong>一经声明，在其生命周期的任何时候都不能再重新赋予新值。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明的同时必须初始化</span></span><br><span class="line"><span class="keyword">const</span> a; <span class="comment">// SyntaxError: 常量声明时没有初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一经声明，不能再赋新值</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 3</span></span><br><span class="line">b = <span class="number">4</span>; <span class="comment">// TypeError: 给常量赋值</span></span><br></pre></td></tr></table></figure>
<p>const除了要遵循以上规则，其他方面与let声明是一样的：</p>
<ul>
<li><strong>块级作用域由最近的一对包含花括号{}界定</strong>。换句话说，if块、while块、function块，甚至连单独的块也是const声明变量的作用域。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"> <span class="keyword">const</span> a = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// ReferenceError: a没有定义</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"> <span class="keyword">const</span> b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// ReferenceError: b没有定义</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">const</span> c = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">// ReferenceError: c没有定义</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">const</span> d = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(d); <span class="comment">// ReferenceError: d没有定义</span></span><br></pre></td></tr></table></figure>

<ul>
<li>const声明只应用到顶级原语或者对象。换句话说，赋值为对象的const变量不能再被重新赋值为其他引用值，但对象的键则不受限制。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o1 = &#123;&#125;;</span><br><span class="line">o1 = &#123;&#125;; <span class="comment">// TypeError: 给常量赋值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> o2 = &#123;&#125;;</span><br><span class="line">o2.name = <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(o2.name); <span class="comment">// &#x27;Jake&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-4用var、let、const-声明变量时的区别（总结）"><a href="#2-3-4用var、let、const-声明变量时的区别（总结）" class="headerlink" title="2.3.4用var、let、const 声明变量时的区别（总结）"></a>2.3.4用var、let、const 声明变量时的区别（总结）</h3><ol>
<li>用 var 声明的变量作用域是它当前的执行上下文，它可以是嵌套的函数，也可以是声明在任何函数外的变量。而 let 和 const 是块级作用域，意味着他们只能在最近的一组花括号（function、if-else 代码块或 for 循环）中访问。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">	<span class="keyword">var</span> bar = <span class="string">&quot;bar&quot;</span>;</span><br><span class="line">	<span class="keyword">let</span> baz = <span class="string">&quot;baz&quot;</span>;</span><br><span class="line">	<span class="keyword">const</span> qux = <span class="string">&quot;qux&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(bar);<span class="comment">//bar</span></span><br><span class="line"><span class="built_in">console</span>.log(baz);<span class="comment">//baz is not defined</span></span><br><span class="line"><span class="built_in">console</span>.log(qux);<span class="comment">//qux is not defined</span></span><br></pre></td></tr></table></figure>



<ol start="2">
<li>var 会使变量提升，这意味着变量可以在声明之前使用。而 let 和 const 不会使变量提升，提前使用会报错。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(foo);<span class="comment">//undefined </span></span><br><span class="line"><span class="comment">//这里注意var声明的变量可以提升但是赋值不可以，所以是undefined</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="string">&quot;foo&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(baz);<span class="comment">//ReferenceError</span></span><br><span class="line"><span class="keyword">let</span> baz = <span class="string">&quot;baz&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(bar);<span class="comment">//ReferenceError</span></span><br><span class="line"><span class="keyword">const</span> bar = <span class="string">&quot;bar&quot;</span>;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>用 var 重复声明变量，不会报错，但是 let 和 const 这样做会报错。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="string">&quot;foo&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="string">&quot;bar&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">//bar</span></span><br><span class="line"><span class="keyword">let</span> baz = <span class="string">&quot;baz&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> baz = <span class="string">&quot;qux&quot;</span>;<span class="comment">//SyntaxError</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>let 和 const 的区别在于：let 允许多次赋值，而 const 只允许一次。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不会报错</span></span><br><span class="line"><span class="keyword">let</span> foo = <span class="string">&quot;foo&quot;</span>;</span><br><span class="line">foo = <span class="string">&quot;bar&quot;</span>;</span><br><span class="line"><span class="comment">//会报错</span></span><br><span class="line"><span class="keyword">const</span> baz = <span class="string">&quot;baz&quot;</span>;</span><br><span class="line">baz = <span class="string">&quot;qux&quot;</span>;</span><br></pre></td></tr></table></figure>





      
    </div>
    <footer class="article-footer">
      <a data-url="https://example.com/2021/05/01/JS%E5%8F%98%E9%87%8F%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F/" data-id="cko5w8rzv000068upb0k78wds" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/05/17/JS%E2%80%94Bom/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Js——函数
        
      </div>
    </a>
  
  
    <a href="/2021/04/29/JavaScript---%E5%87%BD%E6%95%B0/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Js——函数</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/05/17/JS%E2%80%94Bom/">Js——函数</a>
          </li>
        
          <li>
            <a href="/2021/05/01/JS%E5%8F%98%E9%87%8F%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F/">Js——变量与作用域（全）</a>
          </li>
        
          <li>
            <a href="/2021/04/29/JavaScript---%E5%87%BD%E6%95%B0/">Js——函数</a>
          </li>
        
          <li>
            <a href="/2020/12/23/CSS-%E5%AE%9A%E4%BD%8D/">CSS——定位</a>
          </li>
        
          <li>
            <a href="/2020/12/20/CSS-%E6%B5%AE%E5%8A%A8/">CSS——浮动</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>