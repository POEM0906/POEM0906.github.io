<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Js——函数 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="1.函数的声明及调用1.1函数的概念JS中的函数：把一段需要重复使用的代码，用function语法包起来，方便重复调用，分块和简化代码。复杂一点的，也会加入封装、抽象、分类等思想。 1.2函数的声明声明方式：严格意义上两种方式  方式一  1234function 函数名()&amp;#123;     函数体;&amp;#125; (1)function 声明函数的关键字 全部小写        (2)函数一般">
<meta property="og:type" content="article">
<meta property="og:title" content="Js——函数">
<meta property="og:url" content="https://example.com/2021/04/29/JavaScript---%E5%87%BD%E6%95%B0/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="1.函数的声明及调用1.1函数的概念JS中的函数：把一段需要重复使用的代码，用function语法包起来，方便重复调用，分块和简化代码。复杂一点的，也会加入封装、抽象、分类等思想。 1.2函数的声明声明方式：严格意义上两种方式  方式一  1234function 函数名()&amp;#123;     函数体;&amp;#125; (1)function 声明函数的关键字 全部小写        (2)函数一般">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-04-29T12:41:12.250Z">
<meta property="article:modified_time" content="2021-04-29T12:43:57.364Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-JavaScript---函数" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/04/29/JavaScript---%E5%87%BD%E6%95%B0/" class="article-date">
  <time datetime="2021-04-29T12:41:12.250Z" itemprop="datePublished">2021-04-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Js——函数
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-函数的声明及调用"><a href="#1-函数的声明及调用" class="headerlink" title="1.函数的声明及调用"></a>1.函数的声明及调用</h1><h2 id="1-1函数的概念"><a href="#1-1函数的概念" class="headerlink" title="1.1函数的概念"></a>1.1函数的概念</h2><p>JS中的函数：把一段需要重复使用的代码，用function语法包起来，方便重复调用，分块和简化代码。复杂一点的，也会加入封装、抽象、分类等思想。</p>
<h2 id="1-2函数的声明"><a href="#1-2函数的声明" class="headerlink" title="1.2函数的声明"></a>1.2函数的声明</h2><p>声明方式：严格意义上两种方式</p>
<ul>
<li>方式一</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">function</span> 函数名()</span><br><span class="line">&#123;</span><br><span class="line">     函数体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(1)function 声明函数的关键字 全部小写<br>        (2)函数一般是做某件事情，函数名为动词 sayHi<br>       (3)函数不调用，自己不执行</p>
<ul>
<li>方式二</li>
</ul>
<p> <strong>箭头函数</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let arrowSum = (a, b) =&gt;</span><br><span class="line"> &#123;</span><br><span class="line">     return a + b;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>

<p>箭头函数也可以不用大括号，但这样会改变函数的行为。使用大括号就说明包含“函数体”，可以在一个函数中包含多条语句，跟常规的函数一样。如果不使用大括号，那么箭头后面就只能有一行代码，比如一个赋值操作，或者一个表达式。</p>
<p>箭头函数虽然语法简洁，但也有很多场合不适用。箭头函数不能使用arguments、super和new.target，也不能用作构造函数。此外，箭头函数也没有prototype属性。</p>
<h3 id="1-2-1函数声明与函数表达式"><a href="#1-2-1函数声明与函数表达式" class="headerlink" title="1.2.1函数声明与函数表达式"></a>1.2.1函数声明与函数表达式</h3><p>JavaScript引擎在任何代码执行之前，会先读取函数声明，并在执行上下文中生成函数定义。<br>而函数表达式必须等到代码执行到它那一行，才会在执行上下文中生成函数定义。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 没问题</span><br><span class="line"><span class="selector-tag">console</span><span class="selector-class">.log</span>(<span class="selector-tag">sum</span>(10, 10));</span><br><span class="line"><span class="selector-tag">function</span> <span class="selector-tag">sum</span>(<span class="selector-tag">num1</span>, <span class="selector-tag">num2</span>) &#123;</span><br><span class="line"> return num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码可以正常运行，因为函数声明会在任何代码执行之前先被读取并添加到执行上下文。这个过程叫作<strong>函数声明提升</strong>（function declaration hoisting）。在执行代码时，JavaScript引擎会先执行一遍扫描，把发现的函数声明提升到源代码树的顶部。因此即使函数定义出现在调用它们的代码之后，引擎也会把函数声明提升到顶部。如果把前面代码中的函数声明改为等价的函数表达式，那么执行的时候就会出错：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 会出错</span><br><span class="line"><span class="selector-tag">console</span><span class="selector-class">.log</span>(<span class="selector-tag">sum</span>(10, 10));</span><br><span class="line">let sum = function(num1, num2) &#123;</span><br><span class="line"> <span class="selector-tag">return</span> <span class="selector-tag">num1</span> + <span class="selector-tag">num2</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的代码之所以会出错，是因为这个函数定义包含在一个变量初始化语句中，而不是函数声明中。这意味着代码如果没有执行到绿色的那一行，那么执行上下文中就没有函数的定义，所以上面的代码会出错。这并不是因为使用let而导致的，使用var关键字也会碰到同样的问题：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//会出错</span><br><span class="line"><span class="selector-tag">console</span><span class="selector-class">.log</span>(<span class="selector-tag">sum</span>(10, 10));</span><br><span class="line">var sum = function(num1, num2) &#123;</span><br><span class="line"> <span class="selector-tag">return</span> <span class="selector-tag">num1</span> + <span class="selector-tag">num2</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1-3函数的调用"><a href="#1-3函数的调用" class="headerlink" title="1.3函数的调用"></a>1.3函数的调用</h2><p>函数调用：两种方式调用</p>
<ul>
<li>调用方式一：名字(); 函数可以多次调用</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//函数声明</span><br><span class="line"><span class="selector-tag">function</span> <span class="selector-tag">fn</span>()&#123;</span><br><span class="line">    console.log(1);</span><br><span class="line">&#125; </span><br><span class="line">//函数的调用</span><br><span class="line"><span class="selector-tag">fn</span>();</span><br></pre></td></tr></table></figure>
<ul>
<li>调用方式二：在事件中调用，直接写函数名，不使用括号</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//函数声明</span><br><span class="line"><span class="selector-tag">function</span> <span class="selector-tag">fn</span>()&#123;</span><br><span class="line">    console.log(1);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//函数在事件中的调用</span><br><span class="line">document.onclick = fn;</span><br></pre></td></tr></table></figure>
<h1 id="2-函数的传参"><a href="#2-函数的传参" class="headerlink" title="2.函数的传参"></a>2.函数的传参</h1><h2 id="2-1参数"><a href="#2-1参数" class="headerlink" title="2.1参数"></a>2.1参数</h2><p>形参：形式上的参数——给函数声明一个参数；<br>实参：实际的参数——在函数调用时给形参赋的值</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">function</span> 函数名(形参1,形参2....)  //在声明函数的小括号里是形参  (形式上的参数)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">函数名(实参1,实参2....);  //在函数调用的小括号里面是实参 (实际参数)</span><br></pre></td></tr></table></figure>
<p>ECMAScript函数的参数跟大多数其他语言不同。ECMAScript函数既不关心传入的参数个数，也不关心这些参数的数据类型。定义函数时要接收两个参数，并不意味着调用时就传两个参数。你可以传一个、三个，甚至一个也不传，解释器都不会报错。之所以会这样，主要是因为ECMAScript函数的参数在内部表现为一个数组。函数被调用时总会接收一个数组，但函数并不关心这个数组中包含什么。如果数组中什么也没有，那没问题；如果数组的元素超出了要求，那也没问题。事实上，在使用function关键字定义（非箭头）函数时，可以在函数内部访问arguments对象，从中取得传进来的每个参值。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">function</span> <span class="selector-tag">getSum</span>(<span class="selector-tag">num1</span> ,<span class="selector-tag">num2</span>)</span><br><span class="line"> &#123;</span><br><span class="line">      console.log(num1 + num2);</span><br><span class="line">  &#125;</span><br><span class="line">  //1.如果实参和形参个数一样则正常输出结果</span><br><span class="line">  <span class="selector-tag">getSum</span>(1,2);</span><br><span class="line">  //2.如果实参个数多余形参个数，会取到形参的个数</span><br><span class="line">  <span class="selector-tag">getSum</span>(1,2,3);</span><br><span class="line">  //3.如果实参的个数小于形参的个数  多余的形参定义为<span class="selector-tag">undefined</span> 最终结果为<span class="selector-tag">NaN</span>（不是数字）</span><br><span class="line">  //形参可以看做不用声明的变量  <span class="selector-tag">num2</span>是一个变量，但没有接收值，结果就是<span class="selector-tag">undefined</span></span><br><span class="line">  <span class="selector-tag">getSum</span>(1); //<span class="selector-tag">NaN</span></span><br><span class="line">  //建议，尽量让实参个数与形参个数匹配</span><br></pre></td></tr></table></figure>
<h2 id="2-2函数的不定参（可变参）—关键字arguments"><a href="#2-2函数的不定参（可变参）—关键字arguments" class="headerlink" title="2.2函数的不定参（可变参）—关键字arguments"></a>2.2函数的不定参（可变参）—关键字arguments</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">function</span> <span class="selector-tag">doAdd</span>(<span class="selector-tag">num1</span>, <span class="selector-tag">num2</span>) &#123;</span><br><span class="line"> if (arguments.length === 1) &#123;</span><br><span class="line"> <span class="selector-tag">console</span><span class="selector-class">.log</span>(<span class="selector-tag">num1</span> + 10);</span><br><span class="line"> &#125; else if (arguments.length === 2) &#123;</span><br><span class="line"> <span class="selector-tag">console</span><span class="selector-class">.log</span>(<span class="selector-tag">arguments</span><span class="selector-attr">[0]</span> + <span class="selector-tag">num2</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个doAdd()函数中，同时使用了两个命名参数和arguments对象。命名参数num1保存着与arugments[0]一样的值，因此使用谁都无所谓。（同样，num2也保存着跟arguments[1]一样的值。）</p>
<p>arguments对象的值始终会与对应的命名参数同步。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">function</span> <span class="selector-tag">doAdd</span>(<span class="selector-tag">num1</span>, <span class="selector-tag">num2</span>) &#123;</span><br><span class="line"> arguments[1] = 10;</span><br><span class="line"> <span class="selector-tag">console</span><span class="selector-class">.log</span>(<span class="selector-tag">arguments</span><span class="selector-attr">[0]</span> + <span class="selector-tag">num2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个doAdd()函数把第二个参数的值重写为10。因为arguments对象的值会自动同步到对应的命名参数，所以修改arguments[1]也会修改num2的值，因此两者的值都是10。但这并不意味着它们都访问同一个内存地址，它们在内存中还是分开的，只不过会保持同步而已。另外还要记住一点：如果只传了一个参数，然后把arguments[1]设置为某个值，那么这个值并不会反映到第二个命名参数。这是因为arguments对象的长度是根据传入的参数个数，而定义函数时给出的命名参数个数确定的。对于命名参数而言，如果调用函数时没有传这个参数，那么它的值就是undefined。这就类似于定义了变量而没有初始化。比如，如果只给doAdd()传了一个参数，那么num2的值就是undefined。严格模式下，arguments会有一些变化。首先，像前面那样给arguments[1]赋值不会再影响num2的值。就算把arguments[1]设置为10，num2的值仍然还是传入的值。其次，在函数中尝试重写arguments对象会导致语法错误。（代码也不会执行。）</p>
<h1 id="3-函数内部"><a href="#3-函数内部" class="headerlink" title="3.函数内部"></a>3.函数内部</h1><h2 id="3-1-arguments"><a href="#3-1-arguments" class="headerlink" title="3.1 arguments"></a>3.1 arguments</h2><p><strong>arguments对象</strong>，它是一个类数组对象，包含调用函数时传入的所有参数。这个对象只有以function关键字定义函数（相对于使用箭头语法创建函数）时才会有。虽然主要用于包含函数参数，但arguments对象其实还有一个callee属性，是一个指向arguments对象所在函数的指针。来看下面这个经典的阶乘函数：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//求阶乘</span><br><span class="line"><span class="selector-tag">function</span> <span class="selector-tag">factorial</span>(<span class="selector-tag">num</span>) &#123;</span><br><span class="line"> if (num &lt;= 1) &#123;</span><br><span class="line"> <span class="selector-tag">return</span> 1;</span><br><span class="line"> &#125; <span class="selector-tag">else</span> &#123;</span><br><span class="line"> return num * factorial(num - 1);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>阶乘函数一般定义成递归调用的，就像上面这个例子一样。只要给函数一个名称，而且这个名称不会变，这样定义就没有问题。但是，这个函数要正确执行就必须保证函数名是factorial，从而导致了紧密耦合。使用arguments.callee就可以让<strong>函数逻辑与函数名解耦</strong>：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> if (num &lt;= 1) &#123;</span><br><span class="line"> <span class="selector-tag">return</span> 1;</span><br><span class="line"> &#125; <span class="selector-tag">else</span> &#123;</span><br><span class="line"> return num * arguments.callee(num - 1);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个重写之后的factorial()函数已经用arguments.callee代替了之前硬编码的factorial。这意味着无论函数叫什么名称，都可以引用正确的函数。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let trueFactorial = factorial;</span><br><span class="line">factorial = function() &#123;</span><br><span class="line"> <span class="selector-tag">return</span> 0;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="selector-tag">console</span><span class="selector-class">.log</span>(<span class="selector-tag">trueFactorial</span>(5)); // 120</span><br><span class="line"><span class="selector-tag">console</span><span class="selector-class">.log</span>(<span class="selector-tag">factorial</span>(5)); // 0</span><br></pre></td></tr></table></figure>
<p>这里，trueFactorial变量被赋值为factorial，实际上把同一个函数的指针又保存到了另一个位置。然后，factorial函数又被重写为一个返回0的函数。如果像factorial()最初的版本那样不使用arguments.callee，那么像上面这样调用trueFactorial()就会返回0。不过，通过将函数与名称解耦，trueFactorial()就可以正确计算阶乘，而factorial()则只能返回0。</p>
<h2 id="3-2-this"><a href="#3-2-this" class="headerlink" title="3.2 this"></a>3.2 this</h2><p>另一个特殊的对象是this，它在标准函数和箭头函数中有不同的行为。<br><strong>1.在标准函数中，this引用的是把函数当成方法调用的上下文对象</strong>，这时候通常称其为this值（在网页的全局上下文中调用函数时，this指向windows）。来看下面的例子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">window.color = &#x27;red&#x27;;</span><br><span class="line">let o = &#123;</span><br><span class="line"> color: &#x27;blue&#x27;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="selector-tag">function</span> <span class="selector-tag">sayColor</span>() &#123;</span><br><span class="line"> console.log(this.color);</span><br><span class="line">&#125;</span><br><span class="line">sayColor(); // &#x27;red&#x27;</span><br><span class="line">o.sayColor = sayColor;</span><br><span class="line">o.sayColor(); // &#x27;blue&#x27;</span><br></pre></td></tr></table></figure>
<p>定义在全局上下文中的函数sayColor()引用了this对象。这个this到底引用哪个对象必须到函数被调用时才能确定。因此这个值在代码执行的过程中可能会变。如果在全局上下文中调用sayColor()，这结果会输出”red”，因为this指向window，而this.color相当于window.color。而在把sayColor()赋值给o之后再调用o.sayColor()，this会指向o，即this.color相当于o.color，所以会显示”blue”。</p>
<p><strong>2. 在箭头函数中，this引用的是定义箭头函数的上下文</strong>。下面的例子演示了这一点。在对sayColor()的两次调用中，this引用的都是window对象，因为这个箭头函数是在window上下文中定义的：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">window.color = &#x27;red&#x27;;</span><br><span class="line">let o = &#123;</span><br><span class="line"> color: &#x27;blue&#x27;</span><br><span class="line">&#125;;</span><br><span class="line">let sayColor = () =&gt; console.log(this.color);</span><br><span class="line">sayColor(); // &#x27;red&#x27;</span><br><span class="line">o.sayColor = sayColor;</span><br><span class="line">o.sayColor(); // &#x27;red&#x27;</span><br></pre></td></tr></table></figure>
<p><strong>注意:　函数名只是保存指针的变量。因此全局定义的sayColor()函数和o.sayColor()是同一个函数，只不过执行的上下文不同。</strong></p>
<h2 id="3-3-caller"><a href="#3-3-caller" class="headerlink" title="3.3 caller"></a>3.3 caller</h2><p>caller这个属性引用的是调用当前函数的函数，或者如果是在全局作<br>用域中调用的则为null。比如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">function</span> <span class="selector-tag">outer</span>() &#123;</span><br><span class="line"> inner();</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">function</span> <span class="selector-tag">inner</span>() &#123;</span><br><span class="line"> console.log(inner.caller);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">outer</span>();</span><br></pre></td></tr></table></figure>
<p>以上代码会显示outer()函数的源代码。这是因为ourter()调用了inner()，inner.caller指向outer()。</p>
<h2 id="3-4-new-target"><a href="#3-4-new-target" class="headerlink" title="3.4  new.target"></a>3.4  new.target</h2><p>ECMAScript中的函数始终可以作为构造函数实例化一个新对象，也可以作为普通函数被调用。ECMAScript6新增了检测函数是否使用new关键字调用的new.target属性。如果函数是正常调用的，则new.target的值是undefined；如果是使用new关键字调用的，则new.target将引用被调用的构造函数。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">function</span> <span class="selector-tag">King</span>() &#123;</span><br><span class="line"> if (!new.target) &#123;</span><br><span class="line"> throw &#x27;King must be instantiated using &quot;new&quot;&#x27;</span><br><span class="line"> &#125;</span><br><span class="line"> console.log(&#x27;King instantiated using &quot;new&quot;&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">new</span> <span class="selector-tag">King</span>(); // <span class="selector-tag">King</span> <span class="selector-tag">instantiated</span> <span class="selector-tag">using</span> &quot;<span class="selector-tag">new</span>&quot;</span><br><span class="line"><span class="selector-tag">King</span>(); // <span class="selector-tag">Error</span>: <span class="selector-tag">King</span> <span class="selector-tag">must</span> <span class="selector-tag">be</span> <span class="selector-tag">instantiated</span> <span class="selector-tag">using</span> &quot;<span class="selector-tag">new</span>&quot;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://example.com/2021/04/29/JavaScript---%E5%87%BD%E6%95%B0/" data-id="cko2vqepj0000xgupdjav89p3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/05/01/JS%E5%8F%98%E9%87%8F%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Js——变量与作用域（全）
        
      </div>
    </a>
  
  
    <a href="/2020/12/23/CSS-%E5%AE%9A%E4%BD%8D/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">CSS——定位</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/05/17/JS%E2%80%94Bom/">Js——BOM</a>
          </li>
        
          <li>
            <a href="/2021/05/01/JS%E5%8F%98%E9%87%8F%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F/">Js——变量与作用域（全）</a>
          </li>
        
          <li>
            <a href="/2021/04/29/JavaScript---%E5%87%BD%E6%95%B0/">Js——函数</a>
          </li>
        
          <li>
            <a href="/2020/12/23/CSS-%E5%AE%9A%E4%BD%8D/">CSS——定位</a>
          </li>
        
          <li>
            <a href="/2020/12/20/CSS-%E6%B5%AE%E5%8A%A8/">CSS——浮动</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>